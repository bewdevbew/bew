Faire en sorte d'encrypter des clés API également afin que les développeurs crée des API et seront capable de chiffrer les clés API dans une publications afin de les partager à tout ceux qui remplissent les conditions qu'il désirent. Ainsi un développeur pourras mettre comme condition qu'il faudrait x amount en un token ERC20 pour pouvoir accéder à l'API. Et il pourras choisir un token ERC20 quelconque mais sur la plateforme on faciliteras la création d'ERC20 afin qu'il ait son propre token et qu'il puisse être distribué à ceux qui veulent accéder à son API.
Ainsi les grosses API auront une capitalisation élevé cela peut être perçu comme un abonnement mais également comme un investissement. Le développeur sera légitime a dump le token pour se payer un salaire mais il peux également le décentraliser et donc de faire profiter la communauté.

Les développeurs en créant leur profile créeront donc leur token ERC20, le paramètrerons selon leur envie, beaucoup décentralisé, pas beaucoup décentralisé etc.

On commence par une approche permissionless et trustless où chacun peut sortir son token et communique par lens protocol et xmtp pour s'organiser et trouver du job par lui même.

Exemple :

- Je suis développeur frontend et je propose mes services pour ceux qui investissent 1000 tokens dans mon token ERC20.

Chacun peut investir et le frontend met en avant les plus gros investisseur donc le développeur aura une queue de travail et s'organisera tel qu'il le communiquera sur son profile.

Selon comme son token est paramétré la blockchain étant public les gens pourront voir si il respecte ou non son travail.

Si il ne respecte pas rien ne les empêche de retirer leur fond

Nous en tant que dApp, lorsque les utilisateurs passent par notre dApp pour se créer leur propre tokens on se transfère une infime partie de la supply de leur token dans le constructeur. Ils seront capable de décider de combien il nous transfère. Plus il nous transfère, plus son profil auras de chance d'être mis en avant. La supply transféré peut aller de 1 à 100% en passant par notre dApp.

En revanche un avantage seras donné en mettant en avant les profils où notre dApp à le plus de tokens. En tant que dApp on seras également des utilisateurs et par conséquent on proposeras des projets à la communauté et on pourras payer avec des tokens de réputation ou tout autre erc20.
Donc si certains projets veulent être mis en avant ils pourront nous transférer des tokens, ce qui fait que le sponsoring se fait de manière décentralisé et transparente.

Si la mise en avant est efficace les projets vont vouloir être les happy few et donc vont nous transférer les tokens nécessaire pour être mis en avant. Si cette fonctionnalité attire alors cela coûteras de plus en plus cher.
Ce qui signifie également que si un projet est mis en avant et que les utilisateurs ne sont pas satisfait alors le projet perdras de la réputation et donc la valeur va mécaniquement baisser et donc leur mise en avant va diminuer puisque le bag de la dApp seras diminuer.
Inversement si un projet fait un carton auprès des utilisateurs alors la valeur de leur token va augmenter et donc leur mise en avant seras plus importante.

également si un projet a envoyé un nombre conséquent de tokens dans le wallet de la dApp alors il seras mis en avant mais si il ne correspond pas à nos valeurs rien ne nous empêche de nous débarasser de ces tokens et donc de ne pas le mettre en avant.

Au lieu de l'envoyer à l'addresse 0 on pourras effectuer un airdrop à ceux qui utilisent le plus notre dApp et eux seront libre de les garder, de les vendre et récupérer du fiat où de transférer la valeur dans son propre token ERC20.

Ca fait une sorte de boucle vertueuse où les utilisateurs sont récompensés pour leur utilisation de la dApp et les projets sont récompensés pour leur qualité de travail.

Il y a également un système de vote pour les utilisateurs via un token de gouvernance.
. Ainsi les utilisateurs qui ont le plus de tokens peuvent voter pour les projets qu'ils veulent voir être mis en avant. Donc ils auront le droit de décider quel token ERC20 ils veulent airdropé à l'utilisateur afin de réduire la visibilité d'un projet qui ne leur plait pas ou pour récupérer des tokens qu'ils convoitent.

Au début on auras une grande partie de notre tokens de gouvernance afin d'être plus dirigiste sur les votes mais au fur et à mesure on décentraliseras le token afin que la communauté puisse décider de la direction de la dApp.

Ce qu'implique également le token de réputation et le permission less. Les users peuvent très bien dire qu'il mette leur réputation en jeu pour un projet en ne créant pas leur propre tokens et assigne leur profil au token du projet cible.
Ce qui signifie que l'argent que les utilisateurs aurait pu locker dans leurs tokens suite a un airdrop seront locké dans le token du projet qu'il souhaite soutenir. Chacun peu donc apporté son soutien à un projet en particulier et donc le projet pourras se financer de manière décentralisé et transparente.

En commencant par construire autour de la communauté des développeurs et à l'aide des publications on peux stocker beaucoup de data tel que des modules. En reprenant le modèle de notion où chaque élément est une database, ici tout peuvent être un profil y compris les publications. Ce qui signifierais que dans une publication on peux lui assigner un module. Qu'il soit crypté ou encrypté et donc d'assigner des types de modules. Par exemple un développeur pourras créer un module de type "DESIGN_SYSTEM" et changer le design de notre dApp en fonction des props qui lui sont passer en paramètres. Imaginons que notre dApp prend en charge tailwind alors il passeras le design là où il faut en passant les arguments au className.

Plus l'app avance et plus elle deviendras une forme de super app qui prendras en charge tout les types de modules possible et donc les utilisateurs pourront faire leur achat sur notre dApp pour configurer leur propre dApp.

Ainsi les développeurs auront un moyen de se faire de l'argent en créant des modules et en créant au final leurs propre application.

Pour éviter tout module malveillant, les modules accepté par notre dApp seront seulement les modules qui sont vérifié et qui ont été validé par nous même et à terme par la communauté.
Ainsi les développeurs auraient intérêt à investir beaucoup dans le sponsoring pour pouvoir vendre leurs modules.

Les tokens provenant de modules qui ne sont pas vérifié par nous seront automatiquement airdropé aux utilisateurs qui le mériteront le plus. Ce qui ne veux pas dire que ces tokens n'ont aucune valeur puisque c'est possible que les modules permettent de faire des bonnes choses mais n'étant pas vérifié la communauté ne prend pas le risque de les utiliser. Ceux ayant été airdropé auront donc des tokens de réputation avec une possible valeur intéressante.

Notre app auras pour nom de domaine une address ens et le owner seras la dao.

Dans un premier temps on souhaiteras être dirigiste donc on auras un token de gouvernance extrêmement centralisé.
Ensuite on pourrais décentralisé le tout en dilluant au fur et à mesure notre token de gouvernance pour ceux qui ont le plus de tokens de réputation.

Une fois que l'on seras prêt on pourras décentralisé le tout en confiant le ownership a une dao et donc la communauté pourras décider de la direction de la dApp en mettant en gage leur token de réputation sur l'avenir de l'app.
Si un des modules pris en charge par notre app est malveillant alors il seras possible de lui confisquer les tokens mis en gage. Pour éviter tout abus, les tokens confisqué seront redistribué à tout les utilisateurs au prorata de la contribution pour l'App (utilisateurs, builder, publisher, ...) et donc les utilisateurs seront récompensé pour leur utilisation de l'app et pourront également être pénalisé si sa réputation est lié à un des modules malveillant.

Comment ca s'effectue en code ?

Imaginons notre front en plein de layout qui prend en paramètre un design_system, un data_system et un user_system.

DESIGN_SYSTEM:

Disons que pour notre App dans un premier temps, on utilise une stack qui prend en charge Next.js, tailwind et framer-motion.

Alors tout les module design_system compatible avec notre Stack design system et qui ont été validé sur notre dApp pourront être utilisé.
